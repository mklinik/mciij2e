options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)


// Insert a specification of a lexical analysis here.
TOKEN : {
      <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
    |  <#LETTER: ["A"-"Z","_","a"-"z"]>
    |  <#DIGIT: ["0"-"9"]>
    | <INTEGER_LITERAL: (["0"-"9"])+ >
    | <OP: "&&" | "<" | "+" | "-" | "*">
}

SKIP : {
      < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
    | < "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
    | " "
    | "\t"
    | "\n"
}

// The following is a simple grammar that will allow you
// to test the generated lexer.




void Goal() :
{}
{
  ( MiniJavaToken() )*
  <EOF>
}

void MiniJavaToken():
{}
{
      "class"    { System.out.println("got keyword 'class'"); }
    | "{"
    | "public"
    | "static"
    | "void"
    | "main"
    | "("
    | "String"
    | "["
    | "]"
    | ")"
    | "}"
    | "extends"
    | ";"
    | "return"
    | ","
    | "int"
    | "boolean"
    | "="
    | "if"
    | "else"
    | "while"
    | "System.out.println"
    | "."
    | "length"
    | "true"
    | "false"
    | "this"
    | "new"
    | "!"
    | "<OP>"
    | "<IDENTIFIER>"  { System.out.println("got identifier " + token.image); }
    | "<INTEGER_LITERAL>"   { System.out.println("got integer literal " + token.image); }
}


